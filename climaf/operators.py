""" CliMAF handling of external scripts and binaries , and of internal operators (Python funcs)

"""

# Created : S.Senesi - 2014

# The CliMAF software is an environment for Climate Model Assessment. It
# has been developped mainly by CNRM-GAME (Meteo-France and CNRS), and
# by IPSL, in the context of the `CONVERGENCE project
# <http://convergence.ipsl.fr/>`_, funded by The
# French 'Agence Nationale de la Recherche' under grant #
# ANR-13-MONU-0008-01
# 
# This software is governed by the CeCILL-C license under French law and
# biding by the rules of distribution of free software. The CeCILL-C
# licence is a free software license,explicitly compatible with the GNU
# GPL (see http://www.gnu.org/licenses/license-list.en.html#CeCILL)

import logging, os, re, sys, subprocess
import driver

# Next definition can be splitted in a set managed by an administrator, and
# other sets managed and fed by users. But it should be enforced that no redefinition
# occurs for some really basic operators (should it ?)
internals=[]
scripts=dict()
operators=dict()
derived_variables=dict()

class scriptFlags():
    def __init__(self,canOpendap=False, canSelectVar=False, 
                 canSelectTime=False, canSelectDomain=False, 
                 canAggregateTime=False, doSqueezeTime=False,doSqueezeSpace=False):
        self.canOpendap=canOpendap
        self.canSelectVar=canSelectVar
        self.canSelectTime=canSelectTime
        self.canSelectDomain=canSelectDomain
        self.canAggregateTime=canAggregateTime
        self.doSqueezeTime=doSqueezeTime
        self.doSqueezeSpace=doSqueezeSpace

class cscript():
    def __init__(self,name, command, format="nc", canOpendap=False, 
                 doSqueezeTime=False, doSqueezeSpace=False, **kwargs):
        """
        Declare a script or binary as a 'CliMAF operator', and define a function with the same name

        Args:
          name (str): name for the CliMAF operator.
          command (str): script calling sequence, according to the syntax described below.
          format (str): script outputs format -- either 'nc' or 'png'; defaults to 'nc'
          canOpendap (bool, optional): is the script able to use OpenDAP URIs ? default to False
          doSqueezeTime (bool, optional): does the script lead degenerate/aggregate the time 
            dimension ? defaults to False
          doSqueezeSpace (bool, optional): does the script lead degenerate/aggregate the space
            dimension ? defaults to False
          **kwargs : possible keyword arguments, with keys matching '<outname>_var', for providing
            a format string allowing to compute the variable name for output 'outname' (see below).
        
        Returns:
          None
          
        The script calling sequence pattern string (arg 'command') indicates how to build the system call
        which actually launches the script, with a match between python objects and formal arguments;

        For introducing the syntax, please consider this example, with the following commands::
        
        >>> cscript('mycdo','cdo ${operator} ${in} ${out}')
        >>> # define some dataset
        >>> tas_ds = ds(experiment='AMIPV6', variable='tas', period='1980-1981')
        >>> # Apply operator 'mycdo' to dataset 'tas_ds', choosing a given 'operator' argument
        >>> tas_avg = mycdo(tas_ds,operator='timavg')
        
        CliMAF will later on launch this call behind the curtain::
        
        $ cdo tim_avg /home/my/data/AMIP/AMIP_tas.nc /home/my/tmp/climaf_cache/4e/4.nc

        (where the last filename is generated by CliMAF from the formal exprerssion describing 'tas_avg')

        **Detailed syntax**:

        -  formal arguments appear as : ``${argument}`` (in the example : ``${in}``, ``${out}``, ``${operator}`` )
        
        -  except for reserved keywords, arguments in the pattern will be
           replaced by the values for corresponding keywords used when invoking
           the diagnostic operator:

          - in the example above : argument ``operator`` is replaced by value ``timavg``,
            which is a keyword known to the external binary called, CDO  
        
        -  reserved argument keywords are :
        
         - **in, in_<digit>, ins, ins_<digit>** : they will be
           replaced by CliMAF managed filenames for input data, as
           deduced from dataset description or upstream computation; these
           filenames can actually be remote URLs (if the script can use
           OpenDAP, see args), local 'raw' data files, or CliMAF cache
           filenames
        
          -  **in** stands for the URL of the first dataset invoked in the
             operator call
        
          -  **in_<digit>** stands for the next ones, in the same order
        
          -  **ins** and **ins_<digit>** stand for the case where the script can
             select input from multiple input files or URLs (e.g. when the
             whole period to process spans over multiple files); in that case,
             a single string (surrounded with double quotes) will carry
             multiple URLs

         -  **var, var_<digit>** : when a script can select a variable in a
            multi-variable input stream, this is declared by adding this
            keyword in the calling sequence; CliMAF will replace it by the
            actual variable name to process; 'var' stands for first input
            stream, 'var_<digit>' for the next ones;

            - in the example above, we assume that external binary CDO is
              not tasked with selecting the variable, and that CliMAF must
              feed CDO with a datafile where it has already performed the
              selection
         
         
         - **period, period_<digit>** : when a script can select a time
           period in the content of a file or stream, it should declare it
           by putting this keyword in the pattern, which will be replaced at
           call time by the period written as <date1>-<date2>, where date is
           YYYYMMDDHHMM or shorter depending on the corresponding dataset's
           frequency value;

            - all time intervals are interpreted as [date1, date2[
            - 'period' stands for the first input_stream,
            - 'period_<n>' for the next ones, in the order of actual call;

         -  **domain, domain_<digit>** : when a script can select a domain 
            in the input grid, this is declared by adding this
            keyword in the calling sequence; CliMAF will replace it by the
            domain definition if needed, as 'latmin,latmax,lonmin,lonmax' ;
            'domain' stands for first input stream, 'domain_<digit>' for the 
            next ones;

            - in the example above, we assume that external binary CDO is
              not tasked with selecting the domain, and that CliMAF must
              feed CDO with a datafile where it has already performed the
              selection
         
          - in the example above, this keyword is not used, which means that
            CliMAF has to select the period upstream of feeding CDO with the
            data
         
         - **out, out_<word>** : CliMAF provide file names for output
           files. Main output file must be created by the script with
           the name provided at the location of argument ${out}; using
           arguments like 'out_<word>' tells CliMAF that the script
           provide some secondary output, which will be symbolically
           known in CliMAF syntax as an attribute of the main object; by
           default, the variable name of each output equals the name of
           the output (except for the main ouput, which variable name is
           supposed to be the same as for the first input); for other cases,
           see argument \*\*kwargs to provide a format string, used to derive the
           variable name from first input variable name as in e.g. :
           ``output2_var='std_dev(%s)'`` for the output labelled
           output2 (i.e. declared as '${out_output2}')

           - in the example above, we just apply the convention used by CDO,
             which expects that you provide an output filename as last
             argument on the command line

         - **crs** : will be replaced by the CliMAF Reference Syntax expression
           describing the first input stream; can be useful for plot title
           or legend

        """
        # Check that script name do not clash with an existing symbol 
        if name in dir() and name not in scripts :
            logging.error("operators/cscript : trying to redefine %s, which exists outside CliMAF"%name)
            return None
        if name in scripts : logging.warning("Redefining CliMAF script %s"%name)
        #
        # Check now that script is executable
        scriptcommand=command.split(' ')[0].replace("(","")
        try :
            executable=subprocess.check_output('which '+scriptcommand, \
                                                   shell=True)
        except :  
            logging.error("operators.cscript : defining %s : command %s is not executable"%\
                              (name,scriptcommand))
                # raise ClimafException
            return None
        executable=executable.replace('\n','')
        #
        # Analyze inputs field keywords and populate dict attribute 'inputs' with some properties
        self.inputs=dict()
        it=re.finditer(r"\${(?P<keyw>(?P<mult>mm)?in(?P<serie>s)?(_(?P<n>([\d]+)))?)}",command)
        for oc in it : 
            if (oc.group("n") is not None) : rank=int(oc.group("n"))
            else : rank=0
            if rank in self.inputs :
                logging.error("When defining %s : duplicate declaration for input #%d"%(name,rank))
                return(None)
            multiple=(oc.group("mult") is not None)
            serie=(oc.group("serie") is not None)
            self.inputs[rank]=(oc.group("keyw"),multiple,serie)
        if len(self.inputs)==0 : 
            logging.error(("When defining %s : command %s must include at least one of "+
                          "${in} ${ins} ${min} or ${in_..} for specifying how CliMAF will provide the input filename(s)")%\
                              (name,command))
            return None
        #print self.inputs
        for i in range(len(self.inputs)) :
            if i+1 not in self.inputs and not ( i == 0 and 0  in self.inputs) :
                logging.error("When defining %s : error in input sequence for rank %d"%(name,i+1))
                return(None)
        #
        # Check that command includes an argument allowing for providing at least one output filename
        if command.find("${out") < 0 :
            if format is not None :
                logging.error("(operators.cscript : defining %s : command %d must include "+
                              "'${out_xxx}' for specifying how CliMAF will provide the output(s) filename(s))"%\
                                  (name,command))
                return None
            else: 
                logging.warning("operators.cscript : defining script %s as output-less"%name)
        #
        # Search in call arguments for keywords matching "<output_name>_var" which may provide
        # format string for 'computing' outputs variable name from input variable name
        outvarnames=dict() ; pattern=r"^(.*)_var$"
        for p in kwargs : 
            if re.match(pattern,p):
                outvarnames[re.findall(pattern,p)[0]]=kwargs[p]
        logging.debug("operators.script : outvarnames = "+`outvarnames`)
        #
        # Analyze outputs names , associated variable names (or format strings), and store 
        # it in attribute dict 'outputs' 
        self.outputs=dict()
        it=re.finditer(r"\${out(_(?P<outname>[\w-]*))?}",command)
        for occ in it :
            outname=occ.group("outname") 
            if outname is not None :
                if (outname in outvarnames) : 
                    self.outputs[outname]=outvarnames[outname]
                else :
                    self.outputs[outname]=outname
            else:
                self.outputs[None]="%s"
        logging.debug("operators.script : outputs = "+`self.outputs`)
        #
        canSelectVar=False
        if command.find("${var}") > 0 : canSelectVar=True
        canAggregateTime=False
        if command.find("${ins}") > 0     or command.find("${ins_1}") > 0    :
            canAggregateTime=True
        canSelectTime=False
        if command.find("${period}") > 0  or command.find("${period_1}") > 0 :
            canSelectTime=True
        canSelectDomain=False
        if command.find("${domain}") > 0  or command.find("${domain_1}") > 0 :
            canSelectDomain=True
        self.name=name
        self.command=command
        #
        self.flags=scriptFlags(canOpendap, canSelectVar, canSelectTime, \
            canSelectDomain, canAggregateTime, doSqueezeTime, doSqueezeSpace )
        self.outputFormat=format
        scripts[name]=self

        # Init doc string for the operator
        doc="CliMAF wrapper for command : %s"%self.command
        # try to get a better doc string from colocated doc/directory
        docfilename=os.path.dirname(__file__)+"/../doc/scripts/"+name+".rst"
        #print "docfilen= "+docfilename
        try:
            docfile=open(docfilename)
            doc=docfile.read()
            docfile.close()
        except:
            pass
        #
        # creates a function named as requested, which will invoke
        # capply with that name and same arguments
        exec 'def %s(*args,**dic) :\n  """%s""" \n  return climaf.driver.capply("%s",*args,**dic)\n '%\
            (name,doc,name) \
            in sys.modules['__main__'].__dict__
        logging.debug("CliMAF script %s has been declared"%name)

    def inputs_number(self):
        """ returns the number of distinct arguments of a script which are inputs 
        
        """
        l=re.findall(r"\$\{(mm)?ins?(_\d*)?\}",self.command)
        ls=[]; old=None
        for e in l :
            if e != old : ls.append(e)
            old=e
        return(len(ls))

class coperator():
    def __init__(self,op, command, canOpendap=False, canSelectVar=False, 
	canSelectTime=False, canSelectDomain=False, canAggregateTime=False ):
        logging.error("operators.coperator : not yet developped")


def derive(derivedVar, scriptOp, *invars, **params) :
    """ Define that 'derivedVar' is a derived variable, computed by
    applying 'scriptOp' to input streams which are datasets whose 
    variable names tae the values in '*invars' and the parameter/arguments 
    of scriptOp tae the values in '**params'

    Example , assuming that script 'minus' has been defined as :
        cscript('minus','cdo sub ${in_1} ${in_2} ${out}')
    you may define cloud radiative effect at the surface ('rscre')
    using the difference of values of all-sky and clear-sky net
    radiation at the surface by 
       derived('rscre','minus','rs','rscs')

    argument 'derivedVar' may be a dictionnary, with keys=derived variable
    names and values=scripts outputs names; example :
       cscript('vertical_interp', 'vinterp.sh ${in} surface_pressure=${in_2} 
                                   ${out_l500} ${out_l850} method=${opt}')
       derived({z500 : 'l500' , z850 : 'l850'},'vertical_interp', 'zg', 'ps', opt='log'}
    
    """
    # Action : register the information in a dedicated dict which keys
    # are single derived variable names, and which will be used at the
    # object evaluation step
    # Also : some consistency checks w.r.t. script definition
    if scriptOp in scripts :
        if not isinstance(derivedVar,dict) : derivedVar=dict(out=derivedVar)
        for outname in derivedVar :
            if outname != 'out' and outname not in scriptOp.outvarnames :
                logging.error("operators.derive : %s is not a named  ouput for script %s"%(outname,scriptOp))
                return
            s=scripts[scriptOp]
            if s.inputs_number() != len(invars) :
                logging.error("operators.derive : number of input variables for operator %s is %d, which is inconsistent with script declaration : %s"%(s.name,len(invars),s.command))
                return
            # TBD : check parameters number  ( need to build its list in cscript.init() )
            derived_variables[derivedVar[outname]]=(scriptOp, outname, list(invars), params)
    elif scriptOp in operators :
        logging.warning("operators.derive : cannot yet handle derived variables based on internal operators")
    else : 
        logging.error("operators.derive : second argument must be a script or operator, already declared")



if __name__ == "__main__":
    def ceval(script_name,*args,**dic) :
        print script_name, " has been called with args=",args, " and dic=",dic
        print "Command would be:",
    cscript('test_script' ,'echo $*')
    test_script(arg1=1,arg2='two')

#scripts['eof']='eof "${in}" ${out_eof} ${out_cp}'
#scripts['regress']='regress ${in_1} ${in_2} ${out_regress} ${out_correl}'
#scripts['spatial_average']="cdo fldavg ${datain} ${dataout} ${box} ${dataout2}"
#scripts['eof']="eof ${datain} ${out1} ${dataout2}"

